#!/usr/bin/env python3
#
# Draw call flow graph from a database generated by mk-dwarf-db.py.
#
# Usage: draw-callflow.py [-f <+caller|~callee>] [-n <levels>]
#                         [-x <exclude-symbol>]
#                         [-L <symbol>]
#                         [-o <output-file>] <database>
#
# Options:
#   -f <+caller|-callee>  Follow caller to functions called by the caller, or
#                         follow callee to functions calling the callee.
#   -n <levels>           Number of levels to follow.
#   -x <exclude-symbol>   Exclude the specified symbol. Stop following the
#                         symbol.
#   -L <symbol>           Hightlight the specified symbol.
#   -o <output-file>      Output file name. If not specified, output to stdout.
#
# You can specify multiple -f options to follow multiple call paths.
#
# Example:
#   draw-callflow.py -f +caller -f -callee -n 2 -o callflow.dot my-database
#
# This will draw a call flow graph with two levels of callers and two levels of
# callees.
#
import sys
import optparse
import sqlite3

#
# Database schema:
#
#    CREATE TABLE symbols (
#        id integer primary key asc,
#        name text unique
#    );
#
#    CREATE TABLE calls (
#        caller integer,
#        callee integer
#    );
#

class CallflowNode:
    def __init__(self, id, name, tree):
        self.id = id
        self.name = name
        self.tree = tree
        self.children = []
        self.extra_label = []
        pass

    def add_non_existing_child(self, child):
        if child.name in self.tree.symbols:
            return False
        self.children.append(child)
        self.tree.symbols[child.name] = child
        return True

    def is_in_set(self, set):
        return self.name in set or '@' + str(self.id) in set
    pass

class CallflowTree:
    def __init__(self, id, name, to_callee):
        self.root = CallflowNode(id, name, self)
        self.symbols = {name: self.root}
        self.to_callee = to_callee
        pass

    def draw(self, out):
        if self.to_callee:
            self.draw_to_callee(out)
        else:
            self.draw_to_caller(out)
            pass
        pass

    def draw_to_callee(self, out):
        tasks = [self.root]
        visited = set()
        while tasks:
            node = tasks.pop()
            if node.name not in visited and node.extra_label:
                out.write('"%s" [%s];\n' % (node.name, ','.join(node.extra_label)))
                pass
            for child in node.children:
                if child.name not in visited and child.extra_label:
                    out.write('"%s" [%s];\n' % (child.name, ','.join(child.extra_label)))
                    pass
                if hasattr(node, 'hightlight') and hasattr(child, 'hightlight'):
                    out.write('"%s" -> "%s" [color=red,weight=2];\n' % (node.name, child.name))
                else:
                    out.write('"%s" -> "%s";\n' % (node.name, child.name))
                    pass
                tasks.append(child)
                pass
            pass
        pass

    def draw_to_caller(self, out):
        tasks = [self.root]
        visited = set()
        while tasks:
            node = tasks.pop()
            if node.name not in visited and node.extra_label:
                out.write('"%s" [%s];\n' % (node.name, ','.join(node.extra_label)))
                pass
            for child in node.children:
                if child.name not in visited and child.extra_label:
                    out.write('"%s" [%s];\n' % (child.name, ','.join(child.extra_label)))
                    pass
                if hasattr(node, 'hightlight') and hasattr(child, 'hightlight'):
                    out.write('"%s" -> "%s" [color=red,weight=2];\n' % (child.name, node.name))
                else:
                    out.write('"%s" -> "%s";\n' % (child.name, node.name))
                    pass
                tasks.append(child)
                pass
            pass
        pass
    pass

def create_callflow_tree(conn, name, levels, exclude, highlight, to_callee):
    id = conn.execute("SELECT id FROM symbols WHERE name = ?",
                      (name,)).fetchone()[0]
    tree = CallflowTree(id, name, to_callee)
    if tree.root.is_in_set(highlight):
        tree.root.extra_label.append('color=red')
        tree.root.hightlight = True
        pass
    tasks = [(name, levels)]
    while tasks:
        (name, level) = tasks.pop()
        if level == 0:
            continue
        id = conn.execute("SELECT id FROM symbols WHERE name = ?",
                          (name,)).fetchone()[0]
        if to_callee:
            query = "SELECT callee FROM calls WHERE caller = ?"
        else:
            query = "SELECT caller FROM calls WHERE callee = ?"
            pass
        for row in conn.execute(query, (id,)):
            callee_or_caller = row[0]
            child_name = \
                conn.execute("SELECT name FROM symbols WHERE id = ?",
                             (callee_or_caller,)).fetchone()[0]
            node = CallflowNode(callee_or_caller, child_name, tree)
            if node.is_in_set(highlight):
                node.extra_label.append('color=red')
                node.hightlight = True
                pass
            if tree.symbols[name].add_non_existing_child(node) \
               and child_name not in exclude:
                tasks.append((child_name, level - 1))
                pass
            pass
        pass
    return tree

def usage():
    print("Usage: %s [-f <+caller|-callee>] [-n <levels>]" % sys.argv[0])
    print("          [-x <exclude-symbol>] [-o <output-file>] <database>")
    print("        [-o <output-file>] <database>")
    sys.exit(1)
    pass

def main():
    parser = optparse.OptionParser()
    parser.add_option("-f", "--follow", dest="follow", action="append",
                      help="Follow caller to functions called by the caller, or "
                      "follow callee to functions calling the callee.")
    parser.add_option("-n", "--levels", dest="levels", type="int",
                      help="Number of levels to follow.")
    parser.add_option("-x", "--exclude", dest="exclude", action="append",
                        help="Exclude the specified symbol. Stop following the "
                        "symbol.")
    parser.add_option("-L", "--highlight", dest="highlight", action="append",
                      help="Hightlight the specified symbol.")
    parser.add_option("-o", "--output", dest="output",
                      help="Output file name. If not specified, output to stdout.")
    (options, args) = parser.parse_args()

    if len(args) != 1:
        usage()
        pass

    if options.follow is None:
        usage()
        pass

    if options.levels is None:
        options.levels = 5
        pass

    if options.exclude is None:
        options.exclude = []
        pass

    if options.highlight is None:
        options.highlight = []
        pass

    if options.output is None:
        out = sys.stdout
    else:
        out = open(options.output, "w")
        pass

    conn = sqlite3.connect(args[0])

    tries = []
    for follow in options.follow:
        if follow.startswith("+"):
            tree = create_callflow_tree(conn, follow[1:],
                                        options.levels,
                                        options.exclude,
                                        options.highlight,
                                        True)
        elif follow.startswith("~"):
            tree = create_callflow_tree(conn, follow[1:],
                                        options.levels,
                                        options.exclude,
                                        options.highlight,
                                        False)
        else:
            usage()
            pass
        tries.append(tree)
        pass

    out.write("digraph callflow {\n")
    for tree in tries:
        tree.draw(out)
        pass
    out.write("}\n")
    pass

if __name__ == "__main__":
    main()
    pass

